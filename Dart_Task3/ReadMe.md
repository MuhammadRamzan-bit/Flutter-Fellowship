# Dart Task 3 – Asynchronous Programming & Simulation in Dart

## Overview
This task focuses on understanding **asynchronous programming** in Dart and how it is used to handle time-consuming operations efficiently. The task also includes a small **simulation application** to demonstrate practical usage of async concepts in real scenarios.

This repository helps in understanding how Dart manages asynchronous operations using `Future`, `async`, `await`, and exception handling.

---

## Task Objectives
The main objectives of this task are:

- To understand **asynchronous programming** in Dart
- To learn how `Future`, `async`, and `await` work
- To handle errors using `try-catch`
- To implement different types of Futures
- To apply async concepts in a simulation-based application

---

## Learning Outcomes
Through this task, I learned:

- Difference between synchronous and asynchronous execution
- Creating and handling **Future** objects
- Using `async` and `await` for cleaner asynchronous code
- Different types of Futures in Dart
- Proper **error handling** using `try-catch`
- Applying async programming concepts in real-world–like simulations

---

## Project Structure


---

## Dart Programs Included

### Asynchronous Programming
- `future.dart` – Introduction to Future and delayed execution
- `async.dart` – Using async and await keywords
- `future_types.dart` – Different types of Futures and their behavior
- `trycatch.dart` – Exception handling in asynchronous code

### Simulation Application
- `simulationapp.dart`
  - Demonstrates real-life usage of async concepts
  - Simulates time-based or delayed operations

---

## How to Run the Programs

Follow these steps to run any Dart file:

1. Open terminal or command prompt  
2. Navigate to the `Dart_Task3` folder  
3. Run the Dart file using the command:

```bash
dart filename.dart
```

dart simulationapp.dart

---
## Conclusion
Completing this task strengthened my understanding of asynchronous programming in Dart. It helped me learn how to manage delayed tasks, handle exceptions, and write non-blocking code. These concepts are essential for building responsive applications in Flutter and Dart.
